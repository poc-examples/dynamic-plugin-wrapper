import { createApiRef } from "@backstage/core-plugin-api";
import { ResponseError } from '@backstage/errors';
import { SNYK_ANNOTATION_TARGETID, SNYK_ANNOTATION_TARGETNAME, SNYK_ANNOTATION_TARGETS, SNYK_ANNOTATION_PROJECTIDS, SNYK_ANNOTATION_EXCLUDE_PROJECTIDS, SNYK_ANNOTATION_ORG, SNYK_ANNOTATION_ORGS, } from "../config";
import { mockedProjects } from "../utils/mockedProjects";
import { mockedIssues } from "../utils/mockedIssues";
import { mockedDepGraphs } from "../utils/mockedDepGraphs";
import { mockedProjectDetails } from "../utils/mockedProjectDetails";
const pkg = require('../../package.json');
const DEFAULT_PROXY_PATH_BASE = "";
export const snykApiRef = createApiRef({
    id: "plugin.snyk.service",
});
export class SnykApiClient {
    constructor(options) {
        var _a;
        this.headers = {
            "Content-Type": "application/json",
            "User-Agent": `tech-services/backstage-plugin/${pkg.version || "0.0.0-development"}`,
        };
        this.getIssuesCount = (issues) => {
            const criticalSevCount = issues.filter((issue) => issue.attributes.effective_severity_level === "critical" &&
                !issue.attributes.ignored &&
                (issue.attributes.status !== "resolved" ||
                    this.isShowResolvedInGraphs())).length;
            const highSevCount = issues.filter((issue) => issue.attributes.effective_severity_level === "high" &&
                !issue.attributes.ignored &&
                (issue.attributes.status !== "resolved" ||
                    this.isShowResolvedInGraphs())).length;
            const mediumSevCount = issues.filter((issue) => issue.attributes.effective_severity_level === "medium" &&
                !issue.attributes.ignored &&
                (issue.attributes.status !== "resolved" ||
                    this.isShowResolvedInGraphs())).length;
            const lowSevCount = issues.filter((issue) => issue.attributes.effective_severity_level === "low" &&
                !issue.attributes.ignored &&
                (issue.attributes.status !== "resolved" ||
                    this.isShowResolvedInGraphs())).length;
            return {
                critical: criticalSevCount,
                high: highSevCount,
                medium: mediumSevCount,
                low: lowSevCount,
            };
        };
        this.getIgnoredIssuesCount = (issues) => {
            const criticalSevCount = issues.filter((issue) => issue.attributes.effective_severity_level === "critical" &&
                issue.attributes.ignored &&
                (issue.attributes.status !== "resolved" ||
                    this.isShowResolvedInGraphs())).length;
            const highSevCount = issues.filter((issue) => issue.attributes.effective_severity_level === "high" &&
                issue.attributes.ignored &&
                (issue.attributes.status !== "resolved" ||
                    this.isShowResolvedInGraphs())).length;
            const mediumSevCount = issues.filter((issue) => issue.attributes.effective_severity_level === "medium" &&
                issue.attributes.ignored &&
                (issue.attributes.status !== "resolved" ||
                    this.isShowResolvedInGraphs())).length;
            const lowSevCount = issues.filter((issue) => issue.attributes.effective_severity_level === "low" &&
                issue.attributes.ignored &&
                (issue.attributes.status !== "resolved" ||
                    this.isShowResolvedInGraphs())).length;
            return {
                critical: criticalSevCount,
                high: highSevCount,
                medium: mediumSevCount,
                low: lowSevCount,
            };
        };
        this.discoveryApi = options.discoveryApi;
        this.configApi = options.configApi;
        this.proxyPathBase = (_a = options.proxyPathBase) !== null && _a !== void 0 ? _a : DEFAULT_PROXY_PATH_BASE;
        this.fetchApi = options.fetchApi;
    }
    async getApiUrl() {
        const baseUrl = await this.discoveryApi.getBaseUrl("proxy");
        return `${baseUrl}${this.proxyPathBase}/snyk`;
    }
    async fetch(path, method, isV3 = true) {
        const headers = this.headers;
        if (isV3) {
            headers['Content-Type'] = 'application/vnd.api+json';
        }
        const requestInit = {
            headers,
            method,
        };
        const resp = await this.fetchApi.fetch(path, requestInit);
        if (!resp.ok) {
            throw await ResponseError.fromResponse(resp);
        }
        return resp;
    }
    getSnykAppHost() {
        var _a;
        const appHost = (_a = this.configApi.getOptionalString("snyk.AppHost")) !== null && _a !== void 0 ? _a : this.configApi.getOptionalString("snyk.appHost");
        return appHost !== null && appHost !== void 0 ? appHost : "app.snyk.io";
    }
    isMocked() {
        var _a;
        return (_a = this.configApi.getOptionalBoolean("snyk.mocked")) !== null && _a !== void 0 ? _a : false;
    }
    isShowResolvedInGraphs() {
        var _a;
        return ((_a = this.configApi.getOptionalBoolean("snyk.showResolvedInGraphs")) !== null && _a !== void 0 ? _a : false);
    }
    getSnykApiVersion() {
        var _a;
        return ((_a = this.configApi.getOptionalString("snyk.apiVersion")) !== null && _a !== void 0 ? _a : "2024-02-28");
    }
    getSnykIssuesApiVersion() {
        var _a;
        return ((_a = this.configApi.getOptionalString("snyk.issueApiVersion")) !== null && _a !== void 0 ? _a : "2024-01-23");
    }
    isAvailableInEntity(entity) {
        var _a, _b, _c, _d, _e, _f;
        return (this.isMocked() ||
            ((Boolean((_a = entity.metadata.annotations) === null || _a === void 0 ? void 0 : _a[SNYK_ANNOTATION_ORG]) ||
                Boolean((_b = entity.metadata.annotations) === null || _b === void 0 ? void 0 : _b[SNYK_ANNOTATION_ORGS])) &&
                (Boolean((_c = entity.metadata.annotations) === null || _c === void 0 ? void 0 : _c[SNYK_ANNOTATION_TARGETNAME]) ||
                    Boolean((_d = entity.metadata.annotations) === null || _d === void 0 ? void 0 : _d[SNYK_ANNOTATION_TARGETID]) ||
                    Boolean((_e = entity.metadata.annotations) === null || _e === void 0 ? void 0 : _e[SNYK_ANNOTATION_TARGETS]) ||
                    Boolean((_f = entity.metadata.annotations) === null || _f === void 0 ? void 0 : _f[SNYK_ANNOTATION_PROJECTIDS]))));
    }
    async listAllAggregatedIssues(orgId, projectId) {
        if (this.isMocked()) {
            await new Promise((resolve) => setTimeout(resolve, 500));
            return mockedIssues[projectId];
        }
        const fetchPage = async (url) => {
            var _a;
            const backendBaseUrl = await this.getApiUrl();
            const v3Headers = this.headers;
            v3Headers["Content-Type"] = "application/vnd.api+json";
            const response = await this.fetch(`${backendBaseUrl}${url}`, "GET");
            if (response.status >= 400 && response.status < 600) {
                throw new Error(`Error ${response.status} - Failed fetching Vuln Issues snyk data`);
            }
            const json = await response.json();
            const currentIssues = (json === null || json === void 0 ? void 0 : json.data) || [];
            if ((_a = json === null || json === void 0 ? void 0 : json.links) === null || _a === void 0 ? void 0 : _a.next) {
                const nextPageIssues = await fetchPage(json.links.next);
                return [...currentIssues, ...nextPageIssues];
            }
            return currentIssues;
        };
        const version = this.getSnykIssuesApiVersion();
        const initialApiUrl = `/rest/orgs/${orgId}/issues?version=${version}&scan_item.id=${projectId}&scan_item.type=project&limit=100`;
        return await fetchPage(initialApiUrl);
    }
    async getProjectDetails(orgName, projectId) {
        if (this.isMocked()) {
            await new Promise((resolve) => setTimeout(resolve, 500));
            return mockedProjectDetails[projectId];
        }
        const backendBaseUrl = await this.getApiUrl();
        const apiUrl = `${backendBaseUrl}/v1/org/${orgName}/project/${projectId}`;
        const response = await this.fetch(`${apiUrl}`, "GET", false);
        if (response.status >= 400 && response.status < 600) {
            throw new Error(`Error ${response.status} - Failed fetching ProjectDetails snyk data`);
        }
        return response.json();
    }
    async getOrgSlug(orgId) {
        if (this.isMocked()) {
            await new Promise((resolve) => setTimeout(resolve, 500));
            return "nnillni";
        }
        const backendBaseUrl = await this.getApiUrl();
        const v3Headers = this.headers;
        v3Headers["Content-Type"] = "application/vnd.api+json";
        const version = this.getSnykApiVersion();
        const orgsAPIUrl = `${backendBaseUrl}/rest/orgs/${orgId}?version=${version}`;
        const response = await this.fetch(`${orgsAPIUrl}`, "GET");
        if (response.status >= 400 && response.status < 600) {
            throw new Error(`Error ${response.status} - Failed fetching Org data`);
        }
        const orgResponseData = await response.json();
        const orgData = orgResponseData.data;
        return orgData.attributes.slug;
    }
    async getCompleteProjectsListFromAnnotations(orgId, annotations, ignoreMissingTargets = false) {
        let completeProjectsList = [];
        if (this.isMocked()) {
            completeProjectsList = mockedProjects;
            return completeProjectsList;
        }
        const targetsArray = (annotations === null || annotations === void 0 ? void 0 : annotations[SNYK_ANNOTATION_TARGETS])
            ? annotations === null || annotations === void 0 ? void 0 : annotations[SNYK_ANNOTATION_TARGETS].split(",")
            : [];
        if (annotations === null || annotations === void 0 ? void 0 : annotations[SNYK_ANNOTATION_TARGETNAME]) {
            targetsArray.push(annotations === null || annotations === void 0 ? void 0 : annotations[SNYK_ANNOTATION_TARGETNAME]);
        }
        else if (annotations === null || annotations === void 0 ? void 0 : annotations[SNYK_ANNOTATION_TARGETID]) {
            targetsArray.push(annotations === null || annotations === void 0 ? void 0 : annotations[SNYK_ANNOTATION_TARGETID]);
        }
        if (targetsArray.length > 0) {
            const fullProjectByTargetList = await this.getProjectsListByTargets(orgId, Array.isArray(targetsArray) ? targetsArray : [...targetsArray], ignoreMissingTargets);
            completeProjectsList.push(...fullProjectByTargetList);
        }
        if (annotations === null || annotations === void 0 ? void 0 : annotations[SNYK_ANNOTATION_PROJECTIDS]) {
            const fullProjectByIdList = await this.getProjectsListByProjectIds(orgId, annotations === null || annotations === void 0 ? void 0 : annotations[SNYK_ANNOTATION_PROJECTIDS].split(","));
            completeProjectsList.push(...fullProjectByIdList);
        }
        if (annotations === null || annotations === void 0 ? void 0 : annotations[SNYK_ANNOTATION_EXCLUDE_PROJECTIDS]) {
            let idsToExclude = annotations === null || annotations === void 0 ? void 0 : annotations[SNYK_ANNOTATION_EXCLUDE_PROJECTIDS].split(",");
            idsToExclude = idsToExclude.filter((id) => /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(id));
            completeProjectsList = completeProjectsList.filter((project) => {
                return !idsToExclude.includes(project.id);
            });
        }
        return completeProjectsList;
    }
    async getProjectsListByTargets(orgId, repoName, ignoreMissing = false) {
        const TargetIdsArray = [];
        for (let i = 0; i < repoName.length; i++) {
            try {
                TargetIdsArray.push(`target_id=${await this.getTargetId(orgId, repoName[i])}`);
            }
            catch (e) {
                if (!ignoreMissing)
                    throw e;
            }
        }
        if (TargetIdsArray.length > 0) {
            const backendBaseUrl = await this.getApiUrl();
            const v3Headers = this.headers;
            v3Headers["Content-Type"] = "application/vnd.api+json";
            const version = this.getSnykApiVersion();
            const projectsForTargetUrl = `${backendBaseUrl}/rest/orgs/${orgId}/projects?${TargetIdsArray.join("&")}&limit=100&version=${version}`;
            const response = await this.fetch(`${projectsForTargetUrl}`, "GET");
            if (response.status >= 400 && response.status < 600) {
                throw new Error(`Error ${response.status} - Failed fetching Projects list snyk data`);
            }
            const jsonResponse = await response.json();
            return jsonResponse.data;
        }
        else if (!ignoreMissing) {
            throw new Error(`No target IDs found in org ${orgId} for the targets [${repoName.join(",")}].`);
        }
        else {
            return [];
        }
    }
    async getProjectsListByProjectIds(orgId, projectIdsArray) {
        if (projectIdsArray.length > 0) {
            const backendBaseUrl = await this.getApiUrl();
            const v3Headers = this.headers;
            v3Headers["Content-Type"] = "application/vnd.api+json";
            const version = this.getSnykApiVersion();
            const projectsForProjectIds = `${backendBaseUrl}/rest/orgs/${orgId}/projects?ids=${projectIdsArray.join("%2C")}&limit=100&version=${version}`;
            const response = await this.fetch(projectsForProjectIds, "GET");
            if (response.status >= 400 && response.status < 600) {
                throw new Error(`Error ${response.status} - Failed fetching Projects list snyk data`);
            }
            const jsonResponse = await response.json();
            return jsonResponse.data;
        }
        else {
            throw new Error(`Error loading projects by Project IDs.`);
        }
    }
    async getTargetId(orgId, targetIdentifier) {
        var _a;
        if (targetIdentifier === "") {
            throw new Error(`Error - Unable to find repo name. Please add github.com/project-slug or snyk.io/target-id annotation`);
        }
        const backendBaseUrl = await this.getApiUrl();
        const v3Headers = this.headers;
        v3Headers["Content-Type"] = "application/vnd.api+json";
        let targetId;
        if (/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(targetIdentifier)) {
            targetId = targetIdentifier;
        }
        else {
            const version = this.getSnykApiVersion();
            const targetsAPIUrl = `${backendBaseUrl}/rest/orgs/${orgId}/targets?display_name=${encodeURIComponent(targetIdentifier)}&version=${version}`;
            const targetResponse = await this.fetch(`${targetsAPIUrl}`, "GET");
            if (targetResponse.status >= 400 && targetResponse.status < 600) {
                throw new Error(`Error ${targetResponse.status} - Failed fetching Targets list snyk data`);
            }
            const targetsList = await targetResponse.json();
            const targetsListData = targetsList.data;
            targetId = (_a = targetsListData.find((target) => {
                return target.attributes.display_name === targetIdentifier;
            })) === null || _a === void 0 ? void 0 : _a.id;
            if (!targetId) {
                throw new Error(`Error - Failed finding Target snyk data for repo ${targetIdentifier}`);
            }
        }
        return targetId;
    }
    async getDependencyGraph(orgName, projectId) {
        if (this.isMocked()) {
            await new Promise((resolve) => setTimeout(resolve, 500));
            return mockedDepGraphs[projectId];
        }
        const backendBaseUrl = await this.getApiUrl();
        const apiUrl = `${backendBaseUrl}/v1/org/${orgName}/project/${projectId}/dep-graph`;
        const response = await this.fetch(`${apiUrl}`, "GET", false);
        if (response.status >= 400 && response.status < 600) {
            throw new Error(`Error ${response.status} - Failed fetching DepGraph snyk data`);
        }
        const jsonResponse = await response.json();
        return jsonResponse;
    }
}
//# sourceMappingURL=SnykApiClient.js.map