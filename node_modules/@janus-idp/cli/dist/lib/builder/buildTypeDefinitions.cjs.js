'use strict';

var chalk = require('chalk');
var fs = require('fs-extra');
var path = require('path');
var parallel = require('../parallel.cjs.js');
var paths = require('../paths.cjs.js');
var buildTypeDefinitionsWorker = require('./buildTypeDefinitionsWorker.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

const ignoredMessages = /* @__PURE__ */ new Set(["tsdoc-undefined-tag", "ae-forgotten-export"]);
async function buildTypeDefinitions(targetDirs = [paths.paths.targetDir]) {
  const packageDirs = targetDirs.map(
    (dir) => path.relative(paths.paths.targetRoot, dir)
  );
  const entryPoints = await Promise.all(
    packageDirs.map(async (dir) => {
      const entryPoint = paths.paths.resolveTargetRoot(
        "dist-types",
        dir,
        "src/index.d.ts"
      );
      const declarationsExist = await fs__default.default.pathExists(entryPoint);
      if (!declarationsExist) {
        throw new Error(
          `No declaration files found at ${entryPoint}, be sure to run ${chalk__default.default.bgRed.white(
            "yarn tsc"
          )} to generate .d.ts files before packaging`
        );
      }
      return entryPoint;
    })
  );
  const workerConfigs = packageDirs.map((packageDir) => {
    const targetDir = paths.paths.resolveTargetRoot(packageDir);
    const targetTypesDir = paths.paths.resolveTargetRoot("dist-types", packageDir);
    const extractorOptions = {
      configObject: {
        mainEntryPointFilePath: path.resolve(targetTypesDir, "src/index.d.ts"),
        bundledPackages: [],
        compiler: {
          skipLibCheck: true,
          tsconfigFilePath: paths.paths.resolveTargetRoot("tsconfig.json")
        },
        dtsRollup: {
          enabled: true,
          untrimmedFilePath: path.resolve(targetDir, "dist/index.alpha.d.ts"),
          betaTrimmedFilePath: path.resolve(targetDir, "dist/index.beta.d.ts"),
          publicTrimmedFilePath: path.resolve(targetDir, "dist/index.d.ts")
        },
        newlineKind: "lf",
        projectFolder: targetDir
      },
      configObjectFullPath: targetDir,
      packageJsonFullPath: path.resolve(targetDir, "package.json")
    };
    return { extractorOptions, targetTypesDir };
  });
  const typescriptDir = paths.paths.resolveTargetRoot("node_modules/typescript");
  const hasTypescript = await fs__default.default.pathExists(typescriptDir);
  const typescriptCompilerFolder = hasTypescript ? typescriptDir : void 0;
  await parallel.runWorkerThreads({
    threadCount: 1,
    workerData: {
      entryPoints,
      workerConfigs,
      typescriptCompilerFolder
    },
    worker: buildTypeDefinitionsWorker.buildTypeDefinitionsWorker,
    onMessage: ({
      message,
      targetTypesDir
    }) => {
      if (ignoredMessages.has(message.messageId)) {
        return;
      }
      let text = `${message.text} (${message.messageId})`;
      if (message.sourceFilePath) {
        text += " at ";
        text += path.relative(targetTypesDir, message.sourceFilePath);
        if (message.sourceFileLine) {
          text += `:${message.sourceFileLine}`;
          if (message.sourceFileColumn) {
            text += `:${message.sourceFileColumn}`;
          }
        }
      }
      if (message.logLevel === "error") {
        console.error(chalk__default.default.red(`Error: ${text}`));
      } else if (message.logLevel === "warning" || message.category === "Extractor") {
        console.warn(`Warning: ${text}`);
      } else {
        console.log(text);
      }
    }
  });
}

exports.buildTypeDefinitions = buildTypeDefinitions;
//# sourceMappingURL=buildTypeDefinitions.cjs.js.map
