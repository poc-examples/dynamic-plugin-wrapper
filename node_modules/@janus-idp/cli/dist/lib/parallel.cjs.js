'use strict';

var os = require('os');
var worker_threads = require('worker_threads');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var os__default = /*#__PURE__*/_interopDefaultCompat(os);

const defaultParallelism = Math.ceil(os__default.default.cpus().length / 2);
const PARALLEL_ENV_VAR = "BACKSTAGE_CLI_BUILD_PARALLEL";
function parseParallelismOption(parallel) {
  if (parallel === void 0 || parallel === null) {
    return defaultParallelism;
  } else if (typeof parallel === "boolean") {
    return parallel ? defaultParallelism : 1;
  } else if (typeof parallel === "number" && Number.isInteger(parallel)) {
    if (parallel < 1) {
      return 1;
    }
    return parallel;
  } else if (typeof parallel === "string") {
    if (parallel === "true") {
      return parseParallelismOption(true);
    } else if (parallel === "false") {
      return parseParallelismOption(false);
    }
    const parsed = Number(parallel);
    if (Number.isInteger(parsed)) {
      return parseParallelismOption(parsed);
    }
  }
  throw Error(
    `Parallel option value '${parallel}' is not a boolean or integer`
  );
}
function getEnvironmentParallelism() {
  return parseParallelismOption(process.env[PARALLEL_ENV_VAR]);
}
async function runWorkerThreads(options) {
  const { worker, workerData, threadCount = 1, onMessage } = options;
  return Promise.all(
    Array(threadCount).fill(0).map(async () => {
      const thread = new worker_threads.Worker(`(${workerThread})(${worker})`, {
        eval: true,
        workerData
      });
      return new Promise((resolve, reject) => {
        thread.on("message", (message) => {
          if (message.type === "result") {
            resolve(message.result);
          } else if (message.type === "error") {
            reject(message.error);
          } else if (message.type === "message") {
            onMessage?.(message.message);
          }
        });
        thread.on("error", reject);
        thread.on("exit", (code) => {
          reject(
            new Error(`Unexpected worker thread exit with code ${code}`)
          );
        });
      });
    })
  );
}
function workerThread(workerFunc) {
  const { parentPort, workerData } = require("worker_threads");
  const sendMessage = (message) => {
    parentPort.postMessage({ type: "message", message });
  };
  workerFunc(workerData, sendMessage).then(
    (result) => {
      parentPort.postMessage({
        type: "result",
        index: 0,
        result
      });
    },
    (error) => {
      parentPort.postMessage({ type: "error", error });
    }
  );
}

exports.getEnvironmentParallelism = getEnvironmentParallelism;
exports.parseParallelismOption = parseParallelismOption;
exports.runWorkerThreads = runWorkerThreads;
//# sourceMappingURL=parallel.cjs.js.map
