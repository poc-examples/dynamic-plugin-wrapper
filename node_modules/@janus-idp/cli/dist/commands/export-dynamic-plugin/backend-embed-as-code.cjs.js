'use strict';

var getPackages = require('@manypkg/get-packages');
var fs = require('fs-extra');
var rollup = require('rollup');
var child_process = require('child_process');
var path = require('path');
var types = require('../../lib/builder/types.cjs.js');
var config = require('../../lib/builder/config.cjs.js');
var embedPlugin = require('../../lib/builder/embedPlugin.cjs.js');
var packager = require('../../lib/builder/packager.cjs.js');
var entryPoints = require('../../lib/entryPoints.cjs.js');
var productionPack = require('../../lib/packager/productionPack.cjs.js');
var paths = require('../../lib/paths.cjs.js');
var tasks = require('../../lib/tasks.cjs.js');
var backendUtils = require('./backend-utils.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);

async function backend(roleInfo, opts) {
  if (!fs__default.default.existsSync(paths.paths.resolveTarget("src", "dynamic"))) {
    console.warn(
      `Package doesn't seem to provide dynamic loading entrypoints. You might want to add dynamic loading entrypoints in a src/dynamic folder.`
    );
  }
  const outputs = /* @__PURE__ */ new Set();
  if (roleInfo.output.includes("cjs")) {
    outputs.add(types.Output.cjs);
  }
  if (roleInfo.output.includes("esm")) {
    outputs.add(types.Output.esm);
  }
  const pkgContent = await fs__default.default.readFile(
    paths.paths.resolveTarget("package.json"),
    "utf8"
  );
  const pkg = JSON.parse(pkgContent);
  if (pkg.bundled) {
    throw new Error(
      'Packages exported as dynamic backend plugins should not have the "bundled" field set to true'
    );
  }
  const target = path__default.default.join(paths.paths.targetDir, "dist-dynamic");
  const requiredFiles = ["dist-dynamic/*.*", "dist-dynamic/dist/**"];
  const entryPoints$1 = entryPoints.readEntryPoints(pkg);
  if (entryPoints$1.find((e) => e.mount === "./alpha")) {
    requiredFiles.push("dist-dynamic/alpha/*");
  }
  if (requiredFiles.some((f) => !pkg.files?.includes(f))) {
    console.warn(
      `Package doesn't seem to fully support dynamic loading: its "files" property should include the following entries: [${requiredFiles.map((f) => `"${f}"`).join(", ")}].`
    );
  }
  const mergeWithOutput = [];
  const commonPackage = pkg.name.replace(/-backend$/, "-common");
  if (commonPackage !== pkg.name) {
    mergeWithOutput.push(commonPackage);
  }
  const nodePackage = pkg.name.replace(/-backend$/, "-node");
  if (nodePackage !== pkg.name) {
    mergeWithOutput.push(nodePackage);
  }
  if (opts.embedPackage !== void 0) {
    for (const pkgToEmbed of opts.embedPackage) {
      if (pkg.dependencies === void 0 || !(pkgToEmbed in pkg.dependencies)) {
        console.log(
          `Embeded package '${pkgToEmbed}' is not part of direct dependencies. Are you sure you want to embed it ?`
        );
      }
      mergeWithOutput.push(pkgToEmbed);
      const relatedCommonPackage = pkgToEmbed.replace(/-backend$/, "-common");
      if (relatedCommonPackage !== pkgToEmbed) {
        mergeWithOutput.push(relatedCommonPackage);
      }
      const relatedNodePackage = pkgToEmbed.replace(/-backend$/, "-node");
      if (relatedNodePackage !== pkgToEmbed) {
        mergeWithOutput.push(relatedNodePackage);
      }
    }
  }
  const filter = {
    include: mergeWithOutput,
    exclude: mergeWithOutput.length !== 0 ? void 0 : /.*/
  };
  const stringOrRegexp = (s) => s.startsWith("/") && s.endsWith("/") ? new RegExp(s.slice(1, -1)) : s;
  const moveToPeerDependencies = [
    /@backstage\//,
    ...(opts.sharedPackage || []).filter((p) => !p.startsWith("!")).map(stringOrRegexp)
  ];
  const dontMoveToPeerDependencies = (opts.sharedPackage || []).filter((p) => p.startsWith("!")).map((p) => p.slice(1)).map(stringOrRegexp);
  let interopForAll = void 0;
  const interopForPackage = {};
  for (const mode in opts.overrideInterop) {
    if (!Object.prototype.hasOwnProperty.call(opts.overrideInterop, mode)) {
      continue;
    }
    if (!opts.overrideInterop[mode]?.length) {
      interopForAll = mode;
    }
    for (const interopPkg of opts.overrideInterop[mode]) {
      interopForPackage[interopPkg] = mode;
    }
  }
  const rollupConfigs = await config.makeRollupConfigs({
    outputs,
    minify: Boolean(opts.minify),
    useApiExtractor: false
  });
  if (rollupConfigs.length === 0) {
    throw new Error("Rollup config is missing");
  }
  const dependenciesToAdd = {};
  const rollupConfig = rollupConfigs[0];
  rollupConfig.plugins?.push(
    embedPlugin.embedModules({
      filter,
      addDependency: (embeddedModule, dependencyName, newDependencyVersion) => backendUtils.addToDependenciesForModule({
        dependency: {
          name: dependencyName,
          version: newDependencyVersion
        },
        dependencies: dependenciesToAdd,
        module: embeddedModule
      })
    })
  );
  if (Array.isArray(rollupConfig.output)) {
    rollupConfig.output.forEach((output) => {
      if (output.format === "commonjs") {
        if (interopForAll) {
          console.log(
            `Overriding Interop to '${interopForAll}' for all imports`
          );
        }
        output.interop = (id) => {
          if (id && interopForPackage[id]) {
            console.log(
              `Overriding Interop to '${interopForPackage[id]}' for '${id}'`
            );
            return interopForPackage[id];
          }
          return interopForAll || true;
        };
      }
    });
  }
  await fs__default.default.remove(paths.paths.resolveTarget("dist"));
  try {
    const bundle = await rollup.rollup(rollupConfig);
    if (rollupConfig.output) {
      for (const output of [rollupConfig.output].flat()) {
        await bundle.generate(output);
        await bundle.write(output);
      }
    }
  } catch (error) {
    throw new Error(packager.formatErrorMessage(error));
  }
  if (opts.clean) {
    await fs__default.default.remove(target);
  }
  const monoRepoPackages = await getPackages.getPackages(paths.paths.targetDir);
  await productionPack.productionPack({
    packageDir: "",
    targetDir: target,
    customizeManifest: (pkgToCustomize) => {
      function test(str, expr) {
        if (typeof expr === "string") {
          return str === expr;
        }
        return expr.test(str);
      }
      pkgToCustomize.name = `${pkgToCustomize.name}-dynamic`;
      pkgToCustomize.bundleDependencies = true;
      pkgToCustomize.files = pkgToCustomize.files?.filter(
        (f) => !f.startsWith("dist-dynamic/")
      );
      pkgToCustomize.scripts = {};
      const pkgDependencies = pkgToCustomize.dependencies || {};
      backendUtils.addToMainDependencies(dependenciesToAdd, pkgDependencies);
      if (Object.keys(pkgDependencies).length > 0) {
        pkgToCustomize.dependencies = pkgDependencies;
      }
      if (pkgToCustomize.dependencies) {
        for (const monoRepoPackage of monoRepoPackages.packages) {
          if (pkgToCustomize.dependencies[monoRepoPackage.packageJson.name]) {
            pkgToCustomize.dependencies[monoRepoPackage.packageJson.name] = `^${monoRepoPackage.packageJson.version}`;
          }
        }
        for (const dep in pkgToCustomize.dependencies) {
          if (!Object.prototype.hasOwnProperty.call(
            pkgToCustomize.dependencies,
            dep
          )) {
            continue;
          }
          if (mergeWithOutput.some((merge) => test(dep, merge))) {
            delete pkgToCustomize.dependencies[dep];
            continue;
          }
          if (dontMoveToPeerDependencies.some((dontMove) => test(dep, dontMove))) {
            continue;
          }
          if (moveToPeerDependencies.some((move) => test(dep, move))) {
            console.log(`Moving '${dep}' to peerDependencies`);
            pkgToCustomize.peerDependencies ||= {};
            pkgToCustomize.peerDependencies[dep] = pkgToCustomize.dependencies[dep];
            delete pkgToCustomize.dependencies[dep];
          }
        }
      }
      pkgToCustomize.devDependencies = {};
      const overrides = pkgToCustomize.overrides || {};
      pkgToCustomize.overrides = {
        "@aws-sdk/util-utf8-browser": {
          "@smithy/util-utf8": "^2.0.0"
        },
        ...overrides
      };
      const resolutions = pkgToCustomize.resolutions || {};
      pkgToCustomize.resolutions = {
        "@aws-sdk/util-utf8-browser": "npm:@smithy/util-utf8@~2",
        ...resolutions
      };
    }
  });
  const yarnLock = path__default.default.resolve(target, "yarn.lock");
  const yarnLockExists = fs__default.default.existsSync(yarnLock);
  if (!yarnLockExists) {
    await fs__default.default.ensureFile(yarnLock);
  }
  if (opts.install) {
    const yarn = "yarn";
    const version = child_process.execSync(`${yarn} --version`).toString().trim();
    const yarnInstall = version.startsWith("1.") ? `${yarn} install --production${yarnLockExists ? " --frozen-lockfile" : ""}` : `${yarn} install${yarnLockExists ? " --immutable" : " --no-immutable"}`;
    await tasks.Task.forCommand(yarnInstall, { cwd: target, optional: false });
    await fs__default.default.remove(paths.paths.resolveTarget("dist-dynamic", ".yarn"));
  }
  await fs__default.default.remove(paths.paths.resolveTarget("dist"));
  if (roleInfo.output.includes("types")) {
    outputs.add(types.Output.types);
  }
  await packager.buildPackage({
    outputs,
    minify: Boolean(opts.minify)
  });
  return target;
}

exports.backend = backend;
//# sourceMappingURL=backend-embed-as-code.cjs.js.map
