'use strict';

var chalk = require('chalk');
var fs = require('fs-extra');
var groupBy = require('lodash/groupBy');
var sortBy = require('lodash/sortBy');
var paths = require('../../../lib/paths.cjs.js');
var run = require('../../../lib/run.cjs.js');
var types = require('../types.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var chalk__default = /*#__PURE__*/_interopDefaultCompat(chalk);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var groupBy__default = /*#__PURE__*/_interopDefaultCompat(groupBy);
var sortBy__default = /*#__PURE__*/_interopDefaultCompat(sortBy);

class DependenciesStep {
  constructor(data) {
    this.data = data;
  }
  async run() {
    const { dependencies: dependencies2 } = this.data;
    const byTarget = groupBy__default.default(dependencies2, "target");
    for (const [target, deps] of Object.entries(byTarget)) {
      const pkgPath = paths.paths.resolveTargetRoot(target, "package.json");
      const pkgJson = await fs__default.default.readJson(pkgPath);
      const depTypes = /* @__PURE__ */ new Set();
      for (const dep of deps) {
        depTypes.add(dep.type);
        pkgJson[dep.type][dep.name] = dep.query;
      }
      for (const depType of depTypes) {
        pkgJson[depType] = Object.fromEntries(
          sortBy__default.default(Object.entries(pkgJson[depType]), ([key]) => key)
        );
      }
      await fs__default.default.writeJson(pkgPath, pkgJson, { spaces: 2 });
    }
    console.log();
    console.log(
      `Running ${chalk__default.default.blue("yarn install")} to install new versions`
    );
    console.log();
    await run.run("yarn", ["install"]);
  }
}
const dependencies = types.createStepDefinition({
  type: "dependencies",
  deserialize() {
    throw new Error("The dependency step may not be defined in JSON");
  },
  create(data) {
    return new DependenciesStep(data);
  }
});

exports.dependencies = dependencies;
//# sourceMappingURL=dependencies.cjs.js.map
